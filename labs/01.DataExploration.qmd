---
title: "Lab: Exploring a Dataset"
author: "Gabriele Filomena"
date: "`r Sys.Date()`"
output: html_document
---

*The following material has been readapted from*:

-   https://pietrostefani.github.io/gds/environR.html by Elisabetta Pietrostefani and Carmen Cabrera-Arnau
-   https://raw.githubusercontent.com/dereksonderegger/570L/master/07_DataImport.Rmd

The lecture's slides can be found [here](https://github.com/GDSL-UL/stats/blob/main/lectures/lecture01.pdf).

Before completing the practical, please take this [quiz](https://canvas.liverpool.ac.uk/courses/84668/quizzes/168721).

For the lab sessions and your assignment, you will need the following software:

-   R-4.2.2 (or higher) [The Comprehensive R Archive Network (CRAN)](https://cran.r-project.org/)
-   RStudio 2022.12.0-353 (or higher) [Posit](https://posit.co/download/rstudio-desktop/)

**IMPORTANT: Before starting: verify that you have set the directory correctly and familiarise yourself with working with directories and loading files. These are the [instructions](https://gdsl-ul.github.io/stats/general/wdPaths.html)**.

**Now create a .qmd project. We use the `File -> New File -> Quarto Document..` dropdown option; a menu will appear asking you for the document title, author, and preferred output type. You can select HTML. Call it "*week1*" and save it in your main folder.**

Follow the practical below. You can describe what you are doing in normal text. See [here](https://quarto.org/docs/authoring/markdown-basics.html) for how to format normal text in Markdown documents

Remember, when you want to write code in a markdown document you have to enclose it like this:

```{r class.source = "fold-show", echo = F}
knitr::include_graphics("../img/codeChunk.png")
```

> or you can insert it manually:

```{r class.source = "fold-show", echo = F}
knitr::include_graphics("../img/codeChunk_visual.png")
```

## Practice: Dataset and Dataframes

Within this module we will be working with data stored in so-called datasets. A dataset is a structured collection of data points that represent various measurements or observations, often organized in a tabular format with rows and columns. A dataset might contain information about different locations, such as neighborhoods or cities, with each row representing a place and each column detailing characteristics like population density, average income, or number of green parks. For example, a dataset could be compiled to study patterns in urban mobility, where the data includes the number of daily commuters, the distance they travel, and the mode of transport they use. Datasets provide the essential building blocks for statistical analysis; they enable exploring relationships, identifying patterns, and drawing conclusions about certain phenomena.

Examples of everyday datasets:

-   **Premier League Standings**: Each row represents a team, with columns for points, games played, wins, draws, and losses.
-   **Movie Dataset**: Each row represents a movie, with columns showing its title, genre, release year, director, and rating.
-   **Weather Dataset**: Each row shows a day’s weather in a city, with columns for temperature, humidity, wind speed, and precipitation.

Usually, data is organized in

-   **Columns** of data representing some trait or variable that we might be interested in. In general, we might wish to investigate the relationship between variables.
-   **Rows** represent a single object on which the column traits are measured.

For example, in a grade book for recording students scores throughout the semester, their is one row for every student and columns for each assignment. A greenhouse experiment dataset will have a row for every plant and columns for treatment type and biomass.

### Datasets in R

In R, we want a way of storing data where it feels just as if we had an Excel Spreadsheet where each row represents an observation and each column represents some information about that observation. We will call this object a `data.frame`, an R represention of a data set. The easiest way to understand data frames is to create one.

::: {style="background-color: #FFFBCC; padding: 10px; border-radius: 5px; border: 1px solid #E1C948;"}
**Task**: Copy the code below in your markdown. Create a `data.frame` that represents an instructor's grade book, where each row is a student, and each column represents some sort of assessment.
:::

```{r, warning=FALSE, message=FALSE}
library(dplyr)

Grades <- data.frame(
  Name  = c('Bob','Jeff','Mary','Valerie'), 	
  Exam.1 = c(90, 75, 92, 85),
  Exam.2 = c(87, 71, 95, 81)
)
# Show the data.frame 
# View(Grades)  # show the data in an Excel-like tab.  Doesn't work when knitting 
Grades          # show the output in the console. This works when knitting

```

**To execute just one chunk of code press the green arrow top-right of the chunk:**

```{r class.source = "fold-show", echo = F}
knitr::include_graphics("../img/runChunk.png")
```

R allows two differnt was to access elements of the `data.frame`. First is a matrix-like notation for accessing particular values.

| Format  | Result                            |
|---------|-----------------------------------|
| `[a,b]` | Element in row `a` and column `b` |
| `[a,]`  | All of row `a`                    |
| `[,b]`  | All of column `b`                 |

Because the columns have meaning and we have given them column names, it is desirable to want to access an element by the name of the column as opposed to the column number.

::: {style="background-color: #FFFBCC; padding: 10px; border-radius: 5px; border: 1px solid #E1C948;"}
**Task**: Copy and Run:
:::

```{r, warning=FALSE, message=FALSE}
Grades[, 2]       # print out all of column 2 
Grades$Name       # The $-sign means to reference a column by its label
```

### Importing Data in R

Usually we won't type the data in by hand, but rather load the data from some package. Reading data from external sources is a necessary skill.

***Comma Separated Values*** **Data**

To consider how data might be stored, we first consider the simplest file format: the comma separated values file (`.csv`). In this file type, each of the “cells” of data are separated by a comma. For example, the data file storing scores for three students might be as follows:

```         
Able, Dave, 98, 92, 94
Bowles, Jason, 85, 89, 91
Carr, Jasmine, 81, 96, 97
```

Typically when you open up such a file on a computer with MS Excel installed, Excel will open up the file assuming it is a spreadsheet and put each element in its own cell. However, you can also open the file using a more primitive program (say Notepad in Windows, TextEdit on a Mac) you'll see the raw form of the data.

Having just the raw data without any sort of column header is problematic (which of the three exams was the final??). Ideally we would have column headers that store the name of the column.

```         
LastName, FirstName, Exam1, Exam2, FinalExam
Able, Dave, 98, 92, 94
Bowles, Jason, 85, 89, 91
Carr, Jasmine, 81, 96, 97
```

**Reading (`.csv`) files**

To make R read in the data arranged in this format, we need to tell R three things:

1.  Where does the data live? Often this will be the name of a file on your computer, but the file could just as easily live on the internet (provided your computer has internet access).

2.  Is the first row data or is it the column names?

3.  What character separates the data? Some programs store data using tabs to distinguish between elements, some others use white space. R's mechanism for reading in data is flexible enough to allow you to specify what the separator is.

The primary function that we'll use to read data from a file and into R is the function `read.csv()`. This function has many optional arguments but the most commonly used ones are outlined in the table below.

| Argument           | Default     | Description                                                                                                     |
|------------------|------------------|-------------------------------------|
| `file`             | Required    | A character string denoting the file location.                                                                  |
| `header`           | `TRUE`      | Specifies whether the first line contains column headers.                                                       |
| `sep`              | `","`       | Specifies the character that separates columns. For `read.csv()`, this is usually a comma.                      |
| `skip`             | `0`         | The number of lines to skip before reading data; useful for files with descriptive text before the actual data. |
| `na.strings`       | `"NA"`      | Values that represent missing data; multiple values can be specified, e.g., `c("NA", "-9999")`.                 |
| `quote`            | `"`         | Specifies the character used to quote character strings, typically `"` or `'`.                                  |
| `stringsAsFactors` | `FALSE`     | Controls whether character strings are converted to factors; `FALSE` means they remain as character data.       |
| `row.names`        | `NULL`      | Allows specifying a column as row names, or assigning `NULL` to use default indexing for rows.                  |
| `colClasses`       | `NULL`      | Specifies the data type for each column to speed up reading for large files, e.g., `c("character", "numeric")`. |
| `encoding`         | `"unknown"` | Sets the text encoding of the file, which can be useful for files with special or international characters.     |

Most of the time you just need to specify the file. \|

::: {style="background-color: #FFFBCC; padding: 10px; border-radius: 5px; border: 1px solid #E1C948;"}
Task: Let's read in a dataset of terrorist attacks that have taken place in the UK:
:::

```{r, warning=FALSE, message=FALSE}
attacks <- read.csv(file   = '../data/attacksUK.csv')  # where the data lives                                 
View(attacks)
```

## Practice: Descriptive Statistics

### Summarizing Data

It is very important to be able to take a data set and produce summary statistics such as the mean and standard deviation of a column. For this sort of manipulation, we use the package `dplyr`. This package allows chaining together many common actions to form a particular task.

The fundamental operations to perform on a data set are:

-   **Subsetting** - Returns a dataframe with only particular columns or rows

    – `select` - Selecting a subset of columns by name or column number.

    – `filter` - Selecting a subset of rows from a data frame based on logical expressions.

    – `slice` - Selecting a subset of rows by row number.

-   `arrange` - Re-ordering the rows of a data frame.

-   `mutate` - Add a new column that is some function of other columns.

-   `summarise` - calculate some summary statistic of a column of data. This collapses a set of rows into a single row.

Each of these operations is a function in the package `dplyr`. These functions all have a similar calling syntax:

-   The first argument is a data set.

-   Subsequent arguments describe what to do with the input data frame and you can refer to the columns without using the `df$column` notation.

All of these functions will return a data set.

Let's consider the `summarize` function to calculate the mean score for `Exam.1`. Notice that this takes a data frame of four rows, and summarizes it down to just one row that represents the summarized data for all four students.

```{r, warning=FALSE, message=FALSE}
library(dplyr) # load the library
Grades %>%
  summarize( Exam.1.mean = mean( Exam.1 ) )
```

Similarly you could calculate the **standard deviation** for the exam as well.

```{r, warning=FALSE, message=FALSE}
Grades %>%
  summarize( Exam.1.mean = mean( Exam.1 ),
             Exam.1.sd   = sd(   Exam.1   ) )
```

::: {style="background-color: #FFFBCC; padding: 10px; border-radius: 5px; border: 1px solid #E1C948;"}
**Task:** Write the code above in your markdown file and run it. Do not to copy it this time.
:::

The `%>%` operator works by translating the command `a %>% f(b)` to the expression `f(a,b)`. This operator works on any function `f`. This is useful when we want to start with `x`, and first apply a function `f()`, then `g()`, and then `h()`; the usual R command would be `h(g(f(x)))` which is hard to read. Using the pipe command `%>%`, this sequence of operations becomes `x %>% f() %>% g() %>% h()`.

Below, the code takes the Grades dataframe and calculates a column for the average exam score, and then sorts the data according to the that average score

```{r, warning=FALSE, message=FALSE}
Grades %>%   mutate( Avg.Score = (Exam.1 + Exam.2) / 2 ) %>%   arrange( Avg.Score )
```

You don't have to memorise this.

Let's go back to the terrorist attacks dataframe. There are attacks perpetrated by several different groups. Each record is a single attack and contains information about who perpetrated the attack, what year, how many were killed and how many were wounded. You can get a glimpse of the dataframe with the function head

```{r, warning=FALSE, message=FALSE}
head(attacks, n = 10)
```

We might want to compare different actors and see the mean and standard deviation of the number of people wound, by each group's attack, across time. To do this, we are still going to use the `summarize`, but we will precede that with `group_by(group)` to tell the subsequent `dplyr` functions to perform the actions separately for each breed.

```{r, warning=FALSE, message=FALSE}
attacks %>%
  group_by( group) %>%
  summarise( Mean = mean(attacks$nrWound), 
             Std.Dev = sd(attacks$nrWound))
```

::: {style="background-color: #FFFBCC; padding: 10px; border-radius: 5px; border: 1px solid #E1C948;"}
**Task:** Write the code above in your markdown file and run it. Try out another categorical variable instead of `group` (e.g. `year`) and `nrKilled` instead of `nrWound`.
:::

Let's now move to another dataset to address a research question.

For illustration purposes, we will use the **Family Resources Survey (FRS)**. The FRS is an annual survey conducted by the UK government that collects detailed information about the income, living conditions, and resources of private households across the United Kingdom. Managed by the Department for Work and Pensions (DWP), the FRS provides data that is essential for understanding the economic and social conditions of households and informing public policy.

Consider questions such as:

-   How many respondents (persons) are there in the 2016-17 FRS?
-   How many variables (population attributes) are there?
-   What types of variables are present in the FRS?
-   What is the most detailed geography available in the FRS?

::: {style="background-color: #FFFBCC; padding: 10px; border-radius: 5px; border: 1px solid #E1C948;"}
**Task**: To answer these questions, [download](https://canvas.liverpool.ac.uk/courses/84668/files/12887864?wrap=1) from Canvas, save in the data folder, load and inspect the dataset.
:::

```{r, warning=FALSE, message=FALSE}
# the FRS dataset should be already loaded, otherwise
frs_data <- read.csv("../data/FRS/FRS16-17_labels.csv") 

# Display basic structure 
glimpse(frs_data)
```

and summary:

```{r, warning=FALSE, message=FALSE}
summary(frs_data)
```

### Understanding the Structure of the FRS Datafile

In the FRS data structure, each row represents a person, but:

-   Each person is nested within a family.
-   Each family is nested within a household.

Below is an example dataset structure:

| household | family | person | region               | age_group | sex    | marital_status            | rel_to_hrp                   |
|---------|---------|---------|---------|---------|---------|---------|---------|
| 1         | 1      | 1      | London               | 40-44     | Female | Married/Civil partnership | Spouse                       |
| 1         | 1      | 2      | London               | 40-44     | Male   | Married/Civil partnership | Household Representative     |
| 1         | 1      | 3      | London               | 5-10      | Male   | Single                    | Son/daughter (incl. adopted) |
| 1         | 1      | 4      | London               | 5-10      | Female | Single                    | Son/daughter (incl. adopted) |
| 1         | 1      | 5      | London               | 16-19     | Male   | Single                    | Step-son/daughter            |
| 2         | 1      | 1      | Scotland             | 35-39     | Male   | Single                    | Household Representative     |
| 3         | 1      | 1      | Yorks and the Humber | 35-39     | Female | Married/Civil partnership | Household Representative     |
| 3         | 1      | 2      | Yorks and the Humber | 35-39     | Male   | Married/Civil partnership | Spouse                       |
| 3         | 1      | 3      | Yorks and the Humber | 5-10      | Male   | Single                    | Step-son/daughter            |
| 4         | 1      | 1      | Wales                | 0-4       | Male   | Single                    | Son/daughter (incl. adopted) |
| 4         | 1      | 2      | Wales                | 60-64     | Male   | Married/Civil partnership | Household Representative     |
| 4         | 1      | 3      | Wales                | 55-59     | Female | Married/Civil partnership | Spouse                       |
| 4         | 2      | 3      | Wales                | 30-34     | Female | Single                    | Son/daughter (incl. adopted) |

The first five people in the FRS all belong to the same household (household 1); they also all belong to the same family. This family comprises a married middle-aged couple plus their three children, one of whom is a stepson.

The second household (household 2) comprises only one person – a single middle-aged male.The third household comprises another married couple, this time with two children.

Superficially the fourth household looks similar to households 1 and 2: a married couple plus their daughter. The difference is that this particular married couple is nearing retirement age, and their daughter is middle-aged. Consequently, despite being a child of the married couple, the middle-aged daughter is treated as a separate ‘family’ (family 2 in the household). This is because the FRS (and Census) define a ‘family’ as a couple plus any ‘dependent’ children. A dependent child is defined as a child who is either\` aged 0-15 or aged 16-19, unmarried and in full-time education. All children aged 16-19 who are married or no longer in full-time education are regarded as ‘independent’ adults who form their own family unit, as are all children aged 20+.

The inclusion of all persons in a household allows us more flexibility in the types of research question we can answer. For example, we could explore how the likelihood of a woman being in paid employment `WorkStatus` is influenced by the age of the youngest child still living in her family (if any) `fam_youngest`.

In the FRS (and Census), a "family" is defined as a couple and any "dependent" children. Dependent children are defined as those aged 0–15, or aged 16–19 if unmarried and in full-time education.

### Explore the Distribution of Your Outcome Variable

Before starting your analysis, it is critical to know the type of scale used to measure your outcome variable: is it categorical or continuous? Here we will start off by exploring a continuous variable which can then turn into a categorical variable (e.g. top earners: yes or no). We explore the income distribution in the UK by first looking at the low and high end of the distribution ie. What sorts of people have high (or low) incomes?

In the FRS each person’s annual income is recorded, both gross (pre-tax) and net (post-tax). This income includes all income sources, including earnings, profits, investment returns, state benefits, occupational pensions etc. As it is possible to make a loss on some of these activities, it is also possible (although unusual) for someone’s gross or net annual income in a given year to be negative (representing an overall loss).

::: {style="background-color: #FFFBCC; padding: 10px; border-radius: 5px; border: 1px solid #E1C948;"}
**Task**: Load the FRS dataset into your R environment, if it’s not already loaded, and inspect the data.
:::

Open the dataset in RStudio’s **Data Viewer** to explore its structure, including the `income_gross` and `income_net` variables.

```{r, warning=FALSE, message=FALSE}
 # Open the data in the RStudio Viewer
View(frs_data)
```

in the **Data Viewer** tab, scroll horizontally to locate the `income_gross` and `income_net` columns. If columns are listed alphabetically, they will appear near other attributes that start with "income."

You should notice two things:

-   Incomes are recorded to the nearest £, NOT in income bands.
-   Dependent children almost all have a recorded income of £0.

This second observation highlights the somewhat loose wording of our question above (*What sorts of people have high (or low) incomes?*). To avoid reaching the somewhat banal conclusion that those with the lowest of all incomes are almost all children, we should re-frame the question more precisely as *What sorts of people (excluding dependent children) have low incomes?*

::: {style="background-color: #FFFBCC; padding: 10px; border-radius: 5px; border: 1px solid #E1C948;"}
**Task**: Determine the Scale of the Outcome Variable.
:::

```{r, warning=FALSE, message=FALSE}
# Summarize income variables
summary(frs_data$income_gross)
```

```{r, warning=FALSE, message=FALSE}
# Summarize income variables
summary(frs_data$income_net)
```

::: {style="background-color: #FFFBCC; padding: 10px; border-radius: 5px; border: 1px solid #E1C948;"}
**Task**: Exclude Dependent Children.
:::

You need to select all cases (persons) that are independent, that is where the variable `dependent` has values different from `!=` "Dependent" or equal `==` "Independent".

```{r, warning=FALSE, message=FALSE}
# Filter to include only independent persons
frs_independent <- frs_data %>% filter(dependent != "Dependent")
```

::: {style="background-color: #FFFBCC; padding: 10px; border-radius: 5px; border: 1px solid #E1C948;"}
**Task**: Create a basic histogram (a visualisation lecture is scheduled later on).
:::

The income variables in the FRS are all scale variables so a good starting point is to examine its distribution looking at a histogram of `income_gross`.

```{r, warning=FALSE, message=FALSE}
library(ggplot2)
 
 ggplot(frs_independent, aes(x = income_gross)) +
   geom_histogram(binwidth = 5000, fill = "blue", color = "black") +
   labs(
     title = "Distribution of Gross Household Income",
     x = "Gross Income (£)",
     y = "Frequency"
   ) +
   xlim(0, 90000) +
   theme_minimal()
```

You should see the histogram below. It reveals that the income distribution is very skewed with few people earning high salaries and the majority earning just over or less 35,000 annually.

::: {style="background-color: #FFFBCC; padding: 10px; border-radius: 5px; border: 1px solid #E1C948;"}
**Task**: Adopt a regrouping strategy.
:::

You can also cross-tabulate gross (or net) income with any of the other variables in the FRS to your heart’s content – or can you?

Again, here is important to recall that the income variables in the FRS are all ‘scale’ variables; in other words, they are precise measures rather than broad categories. Consequently, every single person in the FRS potentially has their own unique income value. That could make for a table c. 44,000 rows long (one row per person) if each person has their own unique value. The solution is to create a categorical version of the original income variable by assigning each person to one of a set of income categories (income bands). Having done this, cross-tabulation then becomes possible.

But which strategy to use? Equal intervals, percentiles or ‘ad hoc’. Here I would suggest that ‘ad hoc’ is best: all you want to do is to allocate each independent adult to one of three arbitrarily defined groups: ‘low’, ‘middle’ and ‘high’ income. **Define `Low` and `High` Income Thresholds**

Define thresholds for income categories:

-   Low-income threshold: £\_\_\_\_\_\_\_\_
-   High-income threshold: £\_\_\_\_\_\_\_

::: {style="background-color: #FFFBCC; padding: 10px; border-radius: 5px; border: 1px solid #E1C948;"}
**Task**: Create a New Variable Based on Regrouping of Original Variable.
:::

Recode `income_gross` into categories based on the chosen thresholds.

```{r, warning=FALSE, message=FALSE}
# Define thresholds for income categories 
LOW_THRESHOLD <- 10000 # Replace with the upper limit for low income 
HIGH_THRESHOLD <- 50000 # Replace with the lower limit for high income 

# Define income categories based on thresholds 
frs_independent <- frs_independent %>% 
	mutate(income_category = case_when( 
		income_gross <= LOW_THRESHOLD ~ "Low", 
		income_gross >= HIGH_THRESHOLD ~ "High", 
		TRUE ~ "Middle" ))
```

The `mutate()` function in R, from the **dplyr** package, is used to add or modify columns in a data frame. It allows you to create new variables or transform existing ones by applying calculations or conditional statements directly within the function.

Explanation of the code

-   **`frs_independent %>%`**: The pipe operator `%>%` sends `frs_independent` into `mutate()`, allowing us to apply transformations without reassigning it repeatedly.
-   **`mutate()`**: Starts the transformation process by defining new or modified columns.
-   **`income_category = case_when(...)`**:
    -   This creates a new column named `income_category`.
    -   The `case_when()` function defines conditions for assigning values to this new column.
-   **`case_when()`**:
    -   `case_when()` is used here to assign categorical labels based on conditions.
    -   `income_gross <= LOW_THRESHOLD ~ "Low"`: If `income_gross` is less than or equal to `LOW_THRESHOLD`, `income_category` will be labeled "Low."
    -   `income_gross >= HIGH_THRESHOLD ~ "High"`: If `income_gross` is greater than or equal to `HIGH_THRESHOLD`, `income_category` will be labeled "High."
    -   `TRUE ~ "Middle"`: Any values not meeting the previous conditions are labeled "Middle."

::: {style="background-color: #FFFBCC; padding: 10px; border-radius: 5px; border: 1px solid #E1C948;"}
**Task**: Add some Metadata.
:::

Define metadata for the new variable by labeling income categories.

```{r, warning=FALSE, message=FALSE}
# Add metadata by converting to a factor and defining labels

frs_independent$income_category <- factor(frs_independent$income_category,
 						levels = c("Low", "Middle", "High"), labels = c("<= £10,000", "£10,001 - £49,999", ">= £50,000"))
```

::: {style="background-color: #FFFBCC; padding: 10px; border-radius: 5px; border: 1px solid #E1C948;"}
**Task**: Check your work.
:::

Examine the frequency distribution of the variable you have just created. Both variables should have the same number of missing cases, unless:

-   Missing cases in the old variable have been intentionally converted into valid cases in the new variable.
-   You forgot to allocate a new value to one of the old variable categories, in which case the new variable will have more missing cases than the old variable.

```{r, warning=FALSE, message=FALSE}
# Frequency distribution of income categories
table(frs_independent$income_category)
```

After preparing the data, use cross-tabulations to compare income levels across demographic groups.

```{r, warning=FALSE, message=FALSE}
# Cross-tabulate income category by age group, nationality, etc.
table(frs_independent$income_category, frs_independent$age_group)
```

Explore income distribution across different regions.

```{r, warning=FALSE, message=FALSE}
# Cross-tabulate income category by region
table(frs_independent$income_category, frs_independent$region) 
```

**Tips for Cross-Tabulation**

-   Place the income variable in the columns.
-   Add multiple variables in the rows to create simultaneous cross-tabulations.
