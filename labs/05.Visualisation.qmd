---
title: "Lab: Data Visualisation with ggplot"
author: "Gabriele Filomena"
date: "`r Sys.Date()`"
output: html_document
---

## Part A: Towards the Assignment (30 min, or till when you feel you are good to go)

1.  Identify a possible topic:
    -   Load your dataset(s) in Rstudio.
    -   Define your Research Question.
    -   Identify the related variables to analyse.
2.  Discuss ideas:
    -   Get feedback on feasibility and the clarity of research questions.

## Part B - Visualisation: `ggplot2` Functions and Arguments

The **`ggplot2`** package in R is one of the most powerful tools for creating publication-quality visualizations. It uses a layered approach to building plots, starting with data, then adding mappings, geometries, and other components.

### Basic Structure of `ggplot2`

A `ggplot2` plot is built step by step:

```         
ggplot(data, aes(x = <X-axis variable>, y = <Y-axis variable>, <other aesthetics>)) +
  <geom_function()> +
  <scales/themes/other layers>
  
```

### Key Components

#### **`ggplot()`**

-   Initializes the plotting system.
-   Main arguments:
    -   `data`: A data frame containing the variables to be plotted.
    -   `aes()`: Aesthetic mappings to connect data variables to visual properties like `x`, `y`, `color`, `fill`, `size`, etc.

```{r}
library(ggplot2)
```

**Example:**

Let's load the data first:

```{r}
census_data <-  read.csv("../data/Census2021/EW_DistrictPercentages.csv")
```

Plotting Number of residents vs age (mean).

```{r}
ggplot(data = census_data, aes(x = Residents, y = mean_age)) + 
  geom_point()
```

### Geometries in ggplot2

You can plot the following geometries in ggplot:

| **Geometry** | **Function**       | **Use Case**                      |
|--------------|--------------------|-----------------------------------|
| Point        | `geom_point()`     | Scatterplots                      |
| Line         | `geom_line()`      | Line plots                        |
| Bar          | `geom_bar()`       | Bar charts                        |
| Histogram    | `geom_histogram()` | Histograms                        |
| Boxplot      | `geom_boxplot()`   | Boxplots                          |
| Density      | `geom_density()`   | Density plots                     |
| Smooth       | `geom_smooth()`    | Add regression or smoothing lines |

**Example: Scatterplot with `geom_point()`**

```{r}
ggplot(census_data, aes(x = Residents, y = mean_age, color = factor(Region))) +
  geom_point(size = 3)
```

#### Aesthetics: `aes()`

-   Maps data variables to visual properties.
-   Common aesthetics:
    -   `x`: X-axis variable.
    -   `y`: Y-axis variable.
    -   `color`: Changes point/line colors based on a variable.
    -   `fill`: Fills bars/areas based on a variable.
    -   `size`: Controls the size of points/lines.

**Example: Adding color and size aesthetics**

```{r}
ggplot(census_data, aes(x = Residents, y = mean_age, color = factor(Region), size = pct_Very_bad_health)) +
  geom_point()
```

::: {style="background-color: #FFFBCC; padding: 10px; border-radius: 5px; border: 1px solid #E1C948;"}
What's missing in the plot above?How can this be improved?
:::

#### Faceting: `facet_*`

Faceting splits data into subsets and creates multiple small plots.

| **Function**            | **Description**                  |
|-------------------------|----------------------------------|
| `facet_wrap(~var)`      | Wraps plots across rows/columns. |
| `facet_grid(row ~ col)` | Creates a grid layout for plots. |

```{r}
ggplot(census_data, aes(x = Residents, y = mean_age)) +
  geom_point() +
  facet_wrap(~Region)
```

::: {style="background-color: #FFFBCC; padding: 10px; border-radius: 5px; border: 1px solid #E1C948;"}
What are the issues here?
:::

#### Themes (`theme_*`)

Themes control the overall appearance of the plot.

| **Function**      | **Effect**                     |
|-------------------|--------------------------------|
| `theme_minimal()` | Simple and clean theme.        |
| `theme_classic()` | Classic-style plots.           |
| `theme_dark()`    | Dark background.               |
| `theme_void()`    | Minimal with no axes or grids. |

**Applying a theme**

```{r}
ggplot(data = census_data, aes(x = Residents, y = mean_age)) + 
  geom_point() +
  theme_void() +
  labs(title = "Void Theme Example")
```

::: {style="background-color: #FFFBCC; padding: 10px; border-radius: 5px; border: 1px solid #E1C948;"}
Is this any good?
:::

#### Scales

Scales adjust color, size, and axis properties.

| **Scale**              | **Description**                      |
|------------------------|--------------------------------------|
| `scale_color_manual()` | Customizes colors for lines/points.  |
| `scale_fill_brewer()`  | Predefined color palettes for fills. |
| `scale_x_continuous()` | Modifies X-axis properties.          |
| `scale_y_continuous()` | Modifies Y-axis properties.          |

**Example: Customizing axis and colors**

```{r}

library(RColorBrewer)

# Automatically determine the number of colors needed

num_levels <- length(unique(census_data$Region))
# Use an appropriate Brewer palette based on the number of levels
palette <- if (num_levels <= 8) "Set2" else "Paired" # Choose a palette with enough colors
```

The `RColorBrewer` library provides pre-defined color palettes specifically designed for data visualization, ensuring clarity and accessibility. It includes sequential, diverging, and qualitative palettes suitable for various data types and visualization needs.

```{r}
ggplot(census_data, aes(x = Residents, y = mean_age, color = factor(Region))) +
  geom_point(size = 3) +
  scale_color_brewer(palette = palette) + # Dynamically chosen palette
  scale_x_continuous(breaks = seq(50, 350, 50)) +
  labs(title = " Write a title") 
```

You can also create your own palette of colours.

```{r}
ggplot(census_data, aes(x = Residents, y = mean_age, color = factor(Region))) +
  geom_point(size = 3) +
  scale_color_manual(values = c("red", "blue", "green", "purple", "orange", "pink", "brown", "yellow", "gray", "skyblue")) +
  labs(
    title = "Scatterplot of Residents vs Mean Age by Region",
    x = "Residents",
    y = "Mean Age",
    color = "Region"
  ) +
  theme_minimal()
```

### Additional Functions for Customization

-   **`labs()`**: Adds labels for axes, title, and legend.
-   **`annotate()`**: Adds custom text or shapes to the plot.
-   **`coord_flip()`**: Flips X and Y axes for horizontal plots.

Labeling:

```{r}

# labels
labs(
  title = "Plot Title",
  x = "X-Axis Label",
  y = "Y-Axis Label",
  color = "Legend Title"
)
```

Annotations:

```{r}

annotate("text", x = 100, y = 25, label = "Label", color = "red")
```

Flipping:

```{r}
# flipping
ggplot(census_data, aes(x = factor(Region), y = Residents)) +
  geom_boxplot() +
  coord_flip() +
  labs(title = "Horizontal Boxplot")
```

**Key Tips for `ggplot2`**:

-   Start with simple plots and incrementally add layers (`+`).
-   Use themes (`theme_minimal()`, `theme_classic()`) to clean up your plots.
-   Explore palettes with `RColorBrewer` or `viridis` for colorblind-friendly options.

## Part C - Visualisation: Making decent graphs (1h)

This section demonstrates how to create **publication-quality visualizations** in R using `ggplot2`.

**Learning goals** Developing an understanding of, and ability to create academic standard data visualisations.

**Let's load the datasets first** Check the paths, you may need to remove the ".."

```{r}
frs_data <-  read.csv("../data/FamilyResourceSurvey/FRS16-17_labels.csv")
census_data <-  read.csv("../data/Census2021/EW_DistrictPercentages.csv")
```

### Different type of graphs.

#### Distribution of 1 Numerical variable:

**Histogram**

```{r}
ggplot(census_data, aes(x = pct_Age_20_to_29)) + 
  geom_histogram(binwidth = 3, fill = "steelblue", color = "black") +
  labs(title = "Distribution of Numerical Variable", x = "Variable", y = "Count") +
  theme_minimal()
```

`binwidth` controls the width of each bin in the histogram. A histogram divides the range of the numerical variable (e.g. `pct_Age_20_to_29`) into intervals (bins). Each bin represents a range of values, and the height of the bin corresponds to the count (frequency) of observations that fall within that range. In this case, with `binwidth` set to 3, the first bin might represent the range \[0, 3), the second bin \[3, 6), and so on. The choice of `binwidth` determines the level of granularity in the histogram: - Smaller `binwidth`: More bins, more detailed view of the distribution. - Larger `binwidth`: Fewer bins, smoother representation of the data.

Narrow bins (smaller binwidth) show finer details but may be noisy. Wider bins (larger binwidth) aggregate more data into each bin, providing a smoother but less detailed distribution.

**Density Plot**

```{r}
ggplot(census_data, aes(x = Residents)) + 
  geom_density(fill = "lightblue", alpha = 0.7) +
  labs(title = "Residents, Density distribution", x = "Value", y = "Density") +
  theme_minimal()
```

**Histogram + Density Distribution**

```{r}
# Plot histogram with density overlay for a chosen variable (e.g., 'pct_No_qualifications')
ggplot(census_data, aes(x = pct_No_qualifications)) + 
	geom_histogram(aes(y = after_stat(density)), bins = 30, color = "black", fill = "skyblue", alpha = 0.7) +
	geom_density(color = "darkblue", linewidth = 1) +
	labs(title = "Distribution of pct_No_qualifications", x = "Value", y = 	"Density") +
  theme_minimal()
```

**Box Plot**

This looks sad with just one variable, but it's the best way, usually, to plot distributions for numerical variables.

```{r}
library(scales) # For label_comma()

ggplot(census_data, aes(y = Residents)) + 
  geom_boxplot(fill = "lightgreen", color = "black") + 
  labs(title = "Residents Distribution", y = "Number of Residents") + 
  theme_minimal() +
  scale_y_continuous(
    limits = c(0, 500000), 
    labels = label_comma() # Properly placed within scale_y_continuous()
  )
```

Notice the **outliers**. Outliers are data points that deviate significantly from the overall pattern of a dataset. They can arise due to measurement errors, variability in the data, or the presence of extreme values. Outliers can heavily influence statistical analyses, such as means or regression models, potentially leading to misleading conclusions. Identifying and addressing outliers is crucial to ensure robust and accurate results. Boxplots allow spotting them, along with interquartile range (IQR) analysis.

#### Distribution of 1 Categorical variable:

**Bar Chart**

```{r}
ggplot(frs_data, aes(x = highest_qual)) + 
  geom_bar(fill = "skyblue", color = "black") +
  labs(title = "Distribution of 1 Categorical Variable", x = "Highest Educational Qualification", y = "Count") +
  theme_minimal()
```

**Horizontal Bar Chart**

```{r}
ggplot(frs_data, aes(x = highest_qual)) + 
  geom_bar(fill = "lightgreen", color = "black") +
  labs(title = "Horizontal Bar Chart", x = "Highest Educational Qualification", y = "Count", ) +
  coord_flip() + #just flipping
  theme_minimal()
```

### Comparing 2 variables

**1 numerical, 1 categorical: Boxplot**

Household size and Highest Educational Qualification

```{r}
ggplot(frs_data, aes(x = highest_qual, y = hh_size, fill = highest_qual)) +
  geom_boxplot() +
  labs(
    title = "Household Size by Highest Educational Qualification",
    x = "Highest Educational Qualification",
    y = "Household Size"
  ) +
  theme_minimal() +
  theme(legend.position = "none") # don't need this
```

**1 numerical, 1 categorical: Density Ridges**

```{r}
library(ggridges) # need a library for this

ggplot(frs_data, aes(x = hh_size, y = highest_qual, fill = highest_qual)) +
  geom_density_ridges(alpha = 0.7) +
  labs(
    title = "Household Size Distribution by Highest Qualification",
    x = "Household Size",
    y = "Highest Qualification"
  ) +
  theme_minimal()
```

**2 Categorical Variables: Stacked Bar Chart**

Notice some adjustments for making the labels look better

```{r}

ggplot(frs_data, aes(x = highest_qual, fill = health)) +
  geom_bar(position = "stack") +
  labs(
    title = "Health Status by Highest Qualification",
    x = "Highest Qualification",
    y = "Count of Individuals",
    fill = "Health Status"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1), # Rotate X-axis labels for readability
    legend.title = element_text(size = 12),           # Adjust legend title size
    legend.text = element_text(size = 10)             # Adjust legend text size
  )

```

**Side-by-Side Bar Chart (Two-Way Frequency Distribution)**

The one above is clearer.

```{r}
ggplot(frs_data, aes(x = health, fill = highest_qual)) +
  geom_bar(position = "dodge") +
  labs(
    title = "Health Status by Highest Qualification",
    x = "Highest Qualification",
    y = "Count of Individuals",
    fill = "Health Status"
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10)
  )
```

**2 Categorical Variable counts to percentages: Stacked Percentage Graph**

Here we convert the counts of two caterogical variables to percentages. We aim to visualise the proportional distribution of one categorical variable (`health`) across levels of another categorical variable (`highest_qual`) using a stacked percentage bar chart. First, we create a cross-tabulation to count the occurrences of each combination of Health and Qualification categories. These counts are then converted into a percentage format relative to the total counts for each Qualification category. This transformation allows us to represent the relative proportions rather than absolute counts, facilitating comparison across categories.

The data is reshaped into a data frame for compatibility with `ggplot2`, where a stacked bar chart with percentage scaling (position = "fill") is generated. The result is a plot that shows how Health statuses are distributed proportionally within each Qualification level.

```{r}
# Create a cross-tabulation of observed counts 
cross_tab <- table(frs_data$health, frs_data$highest_qual) 

# Convert the cross-tabulation to a data frame
cross_tab_df <- as.data.frame(cross_tab)
colnames(cross_tab_df) <- c("Health", "Qualification", "Percentage")
```

And then the visualisation:

```{r}
# Create a stacked percentage bar chart
ggplot(cross_tab_df, aes(x = Qualification, y = Percentage, fill = Health)) +
  geom_bar(stat = "identity", position = "fill") +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(
    title = "Health by Highest Qualification (Percentage)",
    x = "Highest Qualification",
    y = "Percentage",
    fill = "Health Status"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

**3+ Numerical Variables: Boxplot**

To compare three numerical variables using boxplots in ggplot2, one needs to reshape the data to a long format so that each numerical variable is treated as a category in a singlecolumn.

Here’s how you can do it:

Let's load tidyverse first

```{r}
library(tidyverse) # we need tidyverse for this

# Reshape the data into long format
long_data <- census_data %>%
  pivot_longer(
    cols = c(pct_Single, pct_Muslim, pct_Married_opposite_sex_couple),
    names_to = "Variable",
    values_to = "Value"
  )
```

The code above reshapes the data from a wide format to a long format using the `pivot_longer()` function from the `tidyverse` package. In the original dataset, each column represents a separate variable (e.g., `pct_Single`, `pct_Muslim`, ..), and their values are stored in individual columns. The transformation collapses these columns into two new columns: one for the variable names (Variable) and another for their corresponding values (Value). This format is useful for plotting or analysis where variables are treated uniformly, such as when creating boxplots or facet grids in ggplot2.

```{r}
# Create the boxplot
ggplot(long_data, aes(x = Variable, y = Value, fill = Variable)) +
  geom_boxplot() +
  labs(
    title = "Comparison of Three Numerical Variables",
    x = "Variable",
    y = "Value"
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```

#### Visualising Relationships:

**2 Numerical Variables: Scatterplot**

```{r}
ggplot(census_data, aes(x = pct_Single, y = pct_Muslim, color = factor(Country))) +
  geom_point(size = 3, alpha = 0.7) +  
  labs(
    title = "Percentage of Single Population vs Muslim Population by Country",
    x = "Percentage of Single Population",
    y = "Percentage of Muslim Population",
    color = "Country"
  ) +
  theme_minimal()
```

**2 Numerical Variables + 1 Catecorical: Scatterplot**

```{r}
ggplot(census_data, aes(x = pct_Single, y = pct_Muslim, color = factor(Region))) +
  geom_point(size = 3, alpha = 0.7) +  
  labs(
    title = "Percentage of Single Population vs Muslim Population by Region",
    x = "Percentage of Single Population",
    y = "Percentage of Muslim Population",
    color = "Region"
  ) +
  theme_minimal()
```

**3+ Numerical Variables: Correlogram**

```{r}

# Calculate the correlation matrix
cor_matrix <- cor(
  census_data[, c("pct_Males", "pct_Single", "pct_Bad_health")],
  use = "complete.obs"
)

# Convert the correlation matrix into a format suitable for ggplot2
cor_data <- melt(cor_matrix)

# Plot the correlogram
ggplot(data = cor_data, aes(x = Var1, y = Var2, fill = value)) +
  geom_tile(color = "white") + # Create the heatmap
  geom_text(aes(label = sprintf("%.2f", value)), color = "black", size = 4) + # Add correlation values
  scale_fill_gradient2(
    low = "blue", high = "red", mid = "white",
    midpoint = 0, limit = c(-1, 1),
    space = "Lab", name = "Correlation"
  ) +
  labs(
    title = "Correlogram of Demographic Variables",
    subtitle = "Pct Male, Single, and Bad Health",
    x = "",
    y = ""
  ) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1),
    axis.text.y = element_text(size = 10),
    legend.position = "bottom"
  )

```

**3+ Numerical Variables: Scatterplot matrix**

Preparation:

```{r}
# Select the variables
selected_vars <- census_data[, c("pct_Males", "pct_Single", "pct_Bad_health")]

# Create pairwise combinations of variable names
scatter_data <- expand.grid(
  Variable1 = names(selected_vars),
  Variable2 = names(selected_vars)
) %>%
  filter(Variable1 != Variable2) # Remove self-comparisons

# Add the data values for the pairs
scatter_data <- scatter_data %>%
  rowwise() %>%
  mutate(
    Value1 = list(selected_vars[[Variable1]]), # Extract values for Variable1
    Value2 = list(selected_vars[[Variable2]])  # Extract values for Variable2
  ) %>%
  unnest(c(Value1, Value2)) # Unnest the lists into rows
```

This code is used to create a dataset that facilitates generating pairwise scatterplots between selected variables from a dataset. First, it selects the variables of interest (`pct_Males`, `pct_Single`, and `pct_Bad_health`) from the census_data dataset and stores them in a new data frame called `selected_vars`. Then, the `expand.grid()` function is used to generate all possible combinations of these variables, resulting in a data frame with two columns, `Variable1` and `Variable`2, where each row represents a pair of variables (e.g., `pct_Males` vs `pct_Single`). To avoid redundant self-comparisons (e.g., `pct_Males` vs `pct_Males`), the code filters out such rows using filter(Variable1 != Variable2). Finally, the `mutate()` function is applied to map the actual values of the paired variables (Variable1 and Variable2) to two new columns, Value1 and Value2. These columns contain the corresponding data points for the variable pair, enabling the creation of scatterplots where Value1 is plotted against Value2 for each combination.

Visualisation:

```{r}
ggplot(scatter_data, aes(x = Value1, y = Value2)) +
  geom_point(alpha = 0.6, color = "blue") +
  facet_grid(Variable1 ~ Variable2, scales = "free") +
  labs(
    title = "Correlation Matrix",
    x = "",
    y = ""
  ) +
  theme_minimal()
```

## Part D: Publication-Ready Tables with `kableExtra`

Kable extra allows you creating nice formatted tables for a series of ouputs in Rstudio:

```{r}
library(kableExtra)
```

### Summarising datasets

First we select some columns and we get relevant descriptive statistics.

```{# Summarise the data with explicit naming}
summary_data <- census_data %>%
  select(pct_Very_bad_health, pct_No_qualifications, pct_Males, pct_Higher_manager_prof) %>%
  summarise_all(list(mean = mean, sd = sd)) %>%
  rename_with(~ paste0(., c("_mean", "_sd")), everything()) # Rename columns with "_mean" and "_sd"
```

Then, we create a table with kableExtra

```{# Step 2: Reshape the data into a long format}
reshaped_data <- summary_data %>%
  pivot_longer(
    cols = everything(),
    names_to = c("Variable", ".value"),
    names_sep = "_"
  )
  
# Step 3: Create a styled table using kableExtra
reshaped_data %>%
  kbl(
    caption = "Summary Statistics for Selected Variables",
    col.names = c("Variable", "Mean", "Standard Deviation"),
    digits = 3
  ) %>%
  kable_styling(
    full_width = FALSE,
    bootstrap_options = c("striped", "hover", "condensed")
  )
```

### Creating a Well-Formatted Table from a Cross Tabulation

We can also convert a basic cross tabulation to a nice table

```{r}
# cross tabulation
cross_tab <- table(frs_data$health, frs_data$highest_qual) 

# Convert the cross-tabulation to a data frame
cross_tab_df <- as.data.frame(cross_tab)
```

```{r}
colnames(cross_tab_df) <- c("Health", "Qualification", "Percentage")

cross_tab_df %>%
  kbl(caption = "Health and Educational Qualification") %>%
  kable_styling(full_width = FALSE, position = "left") %>%
  add_header_above(c(" " = 1, "Highest Educational Qualification" = 2))
```

### Creating a Well-Formatted Table from a Cross Tabulation

Finally, we can derive a table to show the Multiple Linear Regression results.

```{r}
# Load required libraries
library(broom)

# Fit the regression model
model <- lm(pct_Very_bad_health ~ pct_No_qualifications + pct_Males + pct_Higher_manager_prof, 
            data = census_data)
```

```{r}
# Tidy the regression output
regression_table <- tidy(model) %>%
  select(term, estimate, std.error, statistic, p.value) %>%
  rename(
    Term = term,
    Estimate = estimate,
    `Std. Error` = std.error,
    `t value` = statistic,
    `P value` = p.value
  )
```

Create and style the regression table

```{r}
regression_table %>%
  kbl(
    caption = "Regression Results: Predicting Very Bad Health Percentage",
    digits = 3,
    col.names = c("Term", "Estimate", "Std. Error", "t Value", "P Value")
  ) %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed")) %>%
  column_spec(2:5, width = "3cm") %>% # Adjust column widths
  add_header_above(c(" " = 1, "Coefficients" = 4)) # Add grouped header
```

## Part E: Play with the code

Test the code with other variables and perhaps your own dataset. Change colours, labels and try to understand what the functions mean.
